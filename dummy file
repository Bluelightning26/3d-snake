import board
import neopixel
import time
import random
import analogio
import pwmio
import tm1637
import digitalio


"""









# === Volume control ===
inputVolume = 10  # in percent
volume = inputVolume / 100

# === Display setup ===
display1 = tm1637.TM1637(clk=board.GP22, dio=board.GP28)
display1.brightness(0)

display2 = tm1637.TM1637(clk=board.GP20, dio=board.GP21)
display2.brightness(0)

# === Buzzer setup on GP15 ===
buzzer = pwmio.PWMOut(board.GP15, duty_cycle=0, frequency=440, variable_frequency=True)

def play_note(freq):
    global volume
    buzzer.frequency = int(freq)
    buzzer.duty_cycle = int(65530 * volume)

def stop_note():
    buzzer.duty_cycle = 0

# === Button setup on GP17 ===
button = digitalio.DigitalInOut(board.GP17)
button.direction = digitalio.Direction.INPUT
button.pull = digitalio.Pull.UP

# === Melody sequence ===
melody = [
    130.81, 0, 130.81, 0, 196, 0, 196, 0, 220, 0, 220, 0, 196, 0,
    174.61, 0, 174.61, 0, 164.81, 0, 164.81, 0, 146.83, 0, 146.83, 0, 130.81, 0,
    196, 0, 196, 0, 174.61, 0, 174.61, 0, 164.81, 0, 164.81, 0, 146.83, 0,
    196, 0, 196, 0, 174.61, 0, 174.61, 0, 164.81, 0, 164.81, 0, 146.83, 0,
    130.81, 0, 130.81, 0, 196, 0, 196, 0, 220, 0, 220, 0, 196, 0,
    174.61, 0, 174.61, 0, 164.81, 0, 164.81, 0, 146.83, 0, 146.83, 0,
    130.81, 130.81, 130.81, 0
]

melody_index = 0
note_start_time = time.monotonic()
note_duration = 0.1  # seconds

# === Counter state ===
counter1 = 0
counter2 = 0
last_update = time.monotonic()

# === Main loop ===
while True:
    now = time.monotonic()

    # Reset counters if button is pressed
    if not button.value:
        counter1 = 0
        counter2 = 0
        display1.show("0000")
        display2.show("0000")
        time.sleep(0.2)  # Debounce delay

    # Update counters every 0.1s
    if now - last_update >= 0.1:
        counter1 += 1
        counter2 += 1

        if counter1 > 9999:
            counter1 = 0
        if counter2 > 9999:
            counter2 = 0

        display1.show(f"{counter1:04d}")
        display2.show(f"{counter2:04d}")

        last_update = now

    # Play melody one note at a time
    if melody_index < len(melody):
        if now - note_start_time >= note_duration:
            freq = melody[melody_index]
            if freq == 0:
                stop_note()
            else:
                play_note(freq)
            melody_index += 1
            note_start_time = now
    else:
        melody_index = 0  # Loop the song

    time.sleep(0.005)
    
    """



# initialize score displys display

# display1 = high score display
display1 = tm1637.TM1637(clk=board.GP22, dio=board.GP28)
display1.brightness(0)


# display2 = current score display
display2 = tm1637.TM1637(clk=board.GP20, dio=board.GP21)
display2.brightness(0)



high_score = 0
current_score = 0

display1.show(f"{high_score:04d}")
display2.show(f"{current_score:04d}")










# === Joystick sensitivity settings ===
JOYSTICK_THRESHOLD = 20  # How far from center to count as a movement (0â€“100)
JOYSTICK_LEEWAY = 15     # How much to allow from the non-dominant axis

# Two separate NeoPixel strips
pixels_panels_1_4 = neopixel.NeoPixel(board.GP0, 256, auto_write=False)  # Panels 1-4
pixels_panel_5 = neopixel.NeoPixel(board.GP3, 64, auto_write=False)      # Panel 5

pixels_panels_1_4.brightness = 0.10
pixels_panel_5.brightness = 0.10

PANEL_SIZE = 64
WIDTH = 8
HEIGHT = 8
PANEL_OFFSET = [0, 64, 128, 192]  # Only panels 1-4 now

# Use analog inputs for joystick axes
JOYSTICK_X = analogio.AnalogIn(board.GP26)
JOYSTICK_Y = analogio.AnalogIn(board.GP27)

# Joystick center analog values
CENTER_X = 51196
CENTER_Y = 48571

# Max analog value for scaling (16-bit ADC max)
MAX_ANALOG = 65535

snake = [(4, 4, 1)]
direction = (1, 0, 0)
apple = (random.randint(0, 7), random.randint(0, 7), random.randint(1, 5))

def coord_to_index(x, y, z):
    if z == 5:
        return y * 8 + x
    else:
        base = PANEL_OFFSET[z - 1]
        return base + (7 - y) * 8 + (7 - x)

def set_pixel(x, y, z, color):
    index = coord_to_index(x, y, z)
    if z == 5:
        if 0 <= index < 64:
            pixels_panel_5[index] = color
    else:
        if 0 <= index < 256:
            pixels_panels_1_4[index] = color

def wrap_position(x, y, z, dx, dy, dz):
    nx, ny, nz = x + dx, y + dy, z + dz
    if 0 <= nx < 8 and 0 <= ny < 8 and 1 <= nz <= 5:
        return (nx, ny, nz), (dx, dy, dz)

    if nx == -1:
        if z == 1: return (7, y, 2), (dx, dy, dz)
        elif z == 2: return (7, y, 3), (dx, dy, dz)
        elif z == 3: return (7, y, 4), (dx, dy, dz)
        elif z == 4: return (7, y, 1), (dx, dy, dz)
        elif z == 5: return (y, 0, 4), (0, 1, 0)

    elif nx == 8:
        if z == 1: return (0, y, 4), (dx, dy, dz)
        elif z == 2: return (0, y, 1), (dx, dy, dz)
        elif z == 3: return (0, y, 2), (dx, dy, dz)
        elif z == 4: return (0, y, 3), (dx, dy, dz)
        elif z == 5: return (7 - y, 0, 2), (0, 1, 0)

    elif ny == -1:
        if z == 1: return (7 - x, 0, 5), (0, 1, 0)
        elif z == 2: return (7, 7 - x, 5), (-1, 0, 0)
        elif z == 3: return (x, 7, 5), (0, -1, 0)
        elif z == 4: return (0, x, 5), (1, 0, 0)
        elif z == 5: return (7 - x, 0, 1), (0, 1, 0)

    elif ny == 8:
        if z == 5: return (x, 0, 3), (0, 1, 0)
        else: return None

    return None

def read_joystick_analog():
    global direction
    raw_x = JOYSTICK_X.value
    raw_y = JOYSTICK_Y.value

    diff_x = raw_x - CENTER_X
    diff_y = raw_y - CENTER_Y

    scaled_x = int(diff_x * 100 / (MAX_ANALOG // 2))
    scaled_y = int(diff_y * 100 / (MAX_ANALOG // 2))

    print(f"Joystick analog position: X={raw_x}, Y={raw_y} | Scaled from center: X={scaled_x}%, Y={scaled_y}%")

    if abs(scaled_x) > JOYSTICK_THRESHOLD and abs(scaled_y) <= abs(scaled_x) + JOYSTICK_LEEWAY:
        direction = (1, 0, 0) if scaled_x > 0 else (-1, 0, 0)
    elif abs(scaled_y) > JOYSTICK_THRESHOLD and abs(scaled_x) <= abs(scaled_y) + JOYSTICK_LEEWAY:
        direction = (0, 1, 0) if scaled_y > 0 else (0, -1, 0)

def draw():
    for i in range(256):
        pixels_panels_1_4[i] = (0, 30, 0)
    for i in range(64):
        pixels_panel_5[i] = (0, 30, 0)
    for x, y, z in snake:
        set_pixel(x, y, z, (0, 0, 255))
    ax, ay, az = apple
    set_pixel(ax, ay, az, (255, 0, 0))
    pixels_panels_1_4.show()
    pixels_panel_5.show()

def move():
    global snake, apple, direction

    read_joystick_analog()

    head = snake[-1]
    result = wrap_position(*head, *direction)
    if result is None:
        snake[:] = [(4, 4, 1)]
        direction = (1, 0, 0)
        apple = (random.randint(0, 7), random.randint(0, 7), random.randint(1, 5))
        return

    new_pos, new_dir = result
    if new_pos is None or new_pos in snake:
        snake[:] = [(4, 4, 1)]
        direction = (1, 0, 0)
        apple = (random.randint(0, 7), random.randint(0, 7), random.randint(1, 5))
        return

    if new_dir != direction:
        direction = new_dir

    snake.append(new_pos)
    if new_pos == apple:
        while True:
            apple = (random.randint(0, 7), random.randint(0, 7), random.randint(1, 5))
            if apple not in snake:
                break
    else:
        snake.pop(0)

def show_score():
	global current_score, high_score
	current_score = len(snake) - 1  # Score is the length of the snake minus the initial segment
	display2.show(f"{current_score:04d}")
	
	if current_score > high_score:
		high_score = current_score
		display1.show(f"{high_score:04d}")

def game_loop():
    while True:
        move()
        draw()
        show_score()
        time.sleep(0.1)
        

if(current_score > high_score):
	high_score = current_score
	display1.show(f"{high_score:04d}")

game_loop()



# END OF GAME
